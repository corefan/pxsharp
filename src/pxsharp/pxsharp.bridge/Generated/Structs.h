// File generated by ApiGen on 2013-12-17 15:11:16

struct PxQuat_Managed {
    PxReal x;
    PxReal y;
    PxReal z;
    PxReal w;
};
#ifndef PxQuat_IN
__forceinline PxQuat PxQuat_IN(const PxQuat_Managed& val) {
    PxQuat res;
    res.x = val.x;
    res.y = val.y;
    res.z = val.z;
    res.w = val.w;
    return res;
};
#endif
#ifndef PxQuat_OUT
__forceinline PxQuat_Managed PxQuat_OUT(const PxQuat& val) {
    PxQuat_Managed res;
    res.x = val.x;
    res.y = val.y;
    res.z = val.z;
    res.w = val.w;
    return res;
};
#endif
struct PxVec3_Managed {
    PxReal x;
    PxReal y;
    PxReal z;
};
#ifndef PxVec3_IN
__forceinline PxVec3 PxVec3_IN(const PxVec3_Managed& val) {
    PxVec3 res;
    res.x = val.x;
    res.y = val.y;
    res.z = val.z;
    return res;
};
#endif
#ifndef PxVec3_OUT
__forceinline PxVec3_Managed PxVec3_OUT(const PxVec3& val) {
    PxVec3_Managed res;
    res.x = val.x;
    res.y = val.y;
    res.z = val.z;
    return res;
};
#endif
struct PxBounds3_Managed {
    PxVec3_Managed minimum;
    PxVec3_Managed maximum;
};
#ifndef PxBounds3_IN
__forceinline PxBounds3 PxBounds3_IN(const PxBounds3_Managed& val) {
    PxBounds3 res;
    res.minimum.x = val.minimum.x;
    res.minimum.y = val.minimum.y;
    res.minimum.z = val.minimum.z;
    res.maximum.x = val.maximum.x;
    res.maximum.y = val.maximum.y;
    res.maximum.z = val.maximum.z;
    return res;
};
#endif
#ifndef PxBounds3_OUT
__forceinline PxBounds3_Managed PxBounds3_OUT(const PxBounds3& val) {
    PxBounds3_Managed res;
    res.minimum.x = val.minimum.x;
    res.minimum.y = val.minimum.y;
    res.minimum.z = val.minimum.z;
    res.maximum.x = val.maximum.x;
    res.maximum.y = val.maximum.y;
    res.maximum.z = val.maximum.z;
    return res;
};
#endif
struct PxTransform_Managed {
    PxQuat_Managed q;
    PxVec3_Managed p;
};
#ifndef PxTransform_IN
__forceinline PxTransform PxTransform_IN(const PxTransform_Managed& val) {
    PxTransform res;
    res.q.x = val.q.x;
    res.q.y = val.q.y;
    res.q.z = val.q.z;
    res.q.w = val.q.w;
    res.p.x = val.p.x;
    res.p.y = val.p.y;
    res.p.z = val.p.z;
    return res;
};
#endif
#ifndef PxTransform_OUT
__forceinline PxTransform_Managed PxTransform_OUT(const PxTransform& val) {
    PxTransform_Managed res;
    res.q.x = val.q.x;
    res.q.y = val.q.y;
    res.q.z = val.q.z;
    res.q.w = val.q.w;
    res.p.x = val.p.x;
    res.p.y = val.p.y;
    res.p.z = val.p.z;
    return res;
};
#endif
struct PxBroadPhaseRegion_Managed {
    PxBounds3_Managed bounds;
    void* userData;
};
#ifndef PxBroadPhaseRegion_IN
__forceinline PxBroadPhaseRegion PxBroadPhaseRegion_IN(const PxBroadPhaseRegion_Managed& val) {
    PxBroadPhaseRegion res;
    res.bounds.minimum.x = val.bounds.minimum.x;
    res.bounds.minimum.y = val.bounds.minimum.y;
    res.bounds.minimum.z = val.bounds.minimum.z;
    res.bounds.maximum.x = val.bounds.maximum.x;
    res.bounds.maximum.y = val.bounds.maximum.y;
    res.bounds.maximum.z = val.bounds.maximum.z;
    res.userData = val.userData;
    return res;
};
#endif
#ifndef PxBroadPhaseRegion_OUT
__forceinline PxBroadPhaseRegion_Managed PxBroadPhaseRegion_OUT(const PxBroadPhaseRegion& val) {
    PxBroadPhaseRegion_Managed res;
    res.bounds.minimum.x = val.bounds.minimum.x;
    res.bounds.minimum.y = val.bounds.minimum.y;
    res.bounds.minimum.z = val.bounds.minimum.z;
    res.bounds.maximum.x = val.bounds.maximum.x;
    res.bounds.maximum.y = val.bounds.maximum.y;
    res.bounds.maximum.z = val.bounds.maximum.z;
    res.userData = val.userData;
    return res;
};
#endif
struct PxBroadPhaseRegionInfo_Managed {
    PxBroadPhaseRegion_Managed region;
    PxU32 nbStaticObjects;
    PxU32 nbDynamicObjects;
    bool active;
    bool overlap;
};
#ifndef PxBroadPhaseRegionInfo_IN
__forceinline PxBroadPhaseRegionInfo PxBroadPhaseRegionInfo_IN(const PxBroadPhaseRegionInfo_Managed& val) {
    PxBroadPhaseRegionInfo res;
    res.region.bounds.minimum.x = val.region.bounds.minimum.x;
    res.region.bounds.minimum.y = val.region.bounds.minimum.y;
    res.region.bounds.minimum.z = val.region.bounds.minimum.z;
    res.region.bounds.maximum.x = val.region.bounds.maximum.x;
    res.region.bounds.maximum.y = val.region.bounds.maximum.y;
    res.region.bounds.maximum.z = val.region.bounds.maximum.z;
    res.region.userData = val.region.userData;
    res.nbStaticObjects = val.nbStaticObjects;
    res.nbDynamicObjects = val.nbDynamicObjects;
    res.active = val.active;
    res.overlap = val.overlap;
    return res;
};
#endif
#ifndef PxBroadPhaseRegionInfo_OUT
__forceinline PxBroadPhaseRegionInfo_Managed PxBroadPhaseRegionInfo_OUT(const PxBroadPhaseRegionInfo& val) {
    PxBroadPhaseRegionInfo_Managed res;
    res.region.bounds.minimum.x = val.region.bounds.minimum.x;
    res.region.bounds.minimum.y = val.region.bounds.minimum.y;
    res.region.bounds.minimum.z = val.region.bounds.minimum.z;
    res.region.bounds.maximum.x = val.region.bounds.maximum.x;
    res.region.bounds.maximum.y = val.region.bounds.maximum.y;
    res.region.bounds.maximum.z = val.region.bounds.maximum.z;
    res.region.userData = val.region.userData;
    res.nbStaticObjects = val.nbStaticObjects;
    res.nbDynamicObjects = val.nbDynamicObjects;
    res.active = val.active;
    res.overlap = val.overlap;
    return res;
};
#endif
struct PxFilterData_Managed {
    PxU32 word0;
    PxU32 word1;
    PxU32 word2;
    PxU32 word3;
};
#ifndef PxFilterData_IN
__forceinline PxFilterData PxFilterData_IN(const PxFilterData_Managed& val) {
    PxFilterData res;
    res.word0 = val.word0;
    res.word1 = val.word1;
    res.word2 = val.word2;
    res.word3 = val.word3;
    return res;
};
#endif
#ifndef PxFilterData_OUT
__forceinline PxFilterData_Managed PxFilterData_OUT(const PxFilterData& val) {
    PxFilterData_Managed res;
    res.word0 = val.word0;
    res.word1 = val.word1;
    res.word2 = val.word2;
    res.word3 = val.word3;
    return res;
};
#endif
struct PxQueryFilterData_Managed {
    PxFilterData_Managed data;
    PxQueryFlag::Enum flags;
    PxClientID clientId;
};
#ifndef PxQueryFilterData_IN
__forceinline PxQueryFilterData PxQueryFilterData_IN(const PxQueryFilterData_Managed& val) {
    PxQueryFilterData res;
    res.data.word0 = val.data.word0;
    res.data.word1 = val.data.word1;
    res.data.word2 = val.data.word2;
    res.data.word3 = val.data.word3;
    res.flags = (PxQueryFlags) (PxU32) val.flags;
    res.clientId = val.clientId;
    return res;
};
#endif
#ifndef PxQueryFilterData_OUT
__forceinline PxQueryFilterData_Managed PxQueryFilterData_OUT(const PxQueryFilterData& val) {
    PxQueryFilterData_Managed res;
    res.data.word0 = val.data.word0;
    res.data.word1 = val.data.word1;
    res.data.word2 = val.data.word2;
    res.data.word3 = val.data.word3;
    res.flags = (PxQueryFlag::Enum) (PxU32) val.flags;
    res.clientId = val.clientId;
    return res;
};
#endif
struct PxActorShape_Managed {
    PxRigidActor* actor;
    PxShape* shape;
};
#ifndef PxActorShape_IN
__forceinline PxActorShape PxActorShape_IN(const PxActorShape_Managed& val) {
    PxActorShape res;
    res.actor = val.actor;
    res.shape = val.shape;
    return res;
};
#endif
#ifndef PxActorShape_OUT
__forceinline PxActorShape_Managed PxActorShape_OUT(const PxActorShape& val) {
    PxActorShape_Managed res;
    res.actor = val.actor;
    res.shape = val.shape;
    return res;
};
#endif
struct PxQueryHit_Managed {
    PxRigidActor* actor;
    PxShape* shape;
    PxU32 faceIndex;
};
#ifndef PxQueryHit_IN
__forceinline PxQueryHit PxQueryHit_IN(const PxQueryHit_Managed& val) {
    PxQueryHit res;
    res.actor = val.actor;
    res.shape = val.shape;
    res.faceIndex = val.faceIndex;
    return res;
};
#endif
#ifndef PxQueryHit_OUT
__forceinline PxQueryHit_Managed PxQueryHit_OUT(const PxQueryHit& val) {
    PxQueryHit_Managed res;
    res.actor = val.actor;
    res.shape = val.shape;
    res.faceIndex = val.faceIndex;
    return res;
};
#endif
struct PxLocationHit_Managed {
    PxRigidActor* actor;
    PxShape* shape;
    PxU32 faceIndex;
    PxHitFlag::Enum flags;
    PxVec3_Managed position;
    PxVec3_Managed normal;
    PxF32 distance;
};
#ifndef PxLocationHit_IN
__forceinline PxLocationHit PxLocationHit_IN(const PxLocationHit_Managed& val) {
    PxLocationHit res;
    res.actor = val.actor;
    res.shape = val.shape;
    res.faceIndex = val.faceIndex;
    res.flags = (PxHitFlags) (PxU32) val.flags;
    res.position.x = val.position.x;
    res.position.y = val.position.y;
    res.position.z = val.position.z;
    res.normal.x = val.normal.x;
    res.normal.y = val.normal.y;
    res.normal.z = val.normal.z;
    res.distance = val.distance;
    return res;
};
#endif
#ifndef PxLocationHit_OUT
__forceinline PxLocationHit_Managed PxLocationHit_OUT(const PxLocationHit& val) {
    PxLocationHit_Managed res;
    res.actor = val.actor;
    res.shape = val.shape;
    res.faceIndex = val.faceIndex;
    res.flags = (PxHitFlag::Enum) (PxU32) val.flags;
    res.position.x = val.position.x;
    res.position.y = val.position.y;
    res.position.z = val.position.z;
    res.normal.x = val.normal.x;
    res.normal.y = val.normal.y;
    res.normal.z = val.normal.z;
    res.distance = val.distance;
    return res;
};
#endif
struct PxRaycastHit_Managed {
    PxRigidActor* actor;
    PxShape* shape;
    PxU32 faceIndex;
    PxHitFlag::Enum flags;
    PxVec3_Managed position;
    PxVec3_Managed normal;
    PxF32 distance;
    PxReal u;
    PxReal v;
    PxU32 padTo16Bytes[3];
};
#ifndef PxRaycastHit_IN
__forceinline PxRaycastHit PxRaycastHit_IN(const PxRaycastHit_Managed& val) {
    PxRaycastHit res;
    res.actor = val.actor;
    res.shape = val.shape;
    res.faceIndex = val.faceIndex;
    res.flags = (PxHitFlags) (PxU32) val.flags;
    res.position.x = val.position.x;
    res.position.y = val.position.y;
    res.position.z = val.position.z;
    res.normal.x = val.normal.x;
    res.normal.y = val.normal.y;
    res.normal.z = val.normal.z;
    res.distance = val.distance;
    res.u = val.u;
    res.v = val.v;
    res.padTo16Bytes[0] = val.padTo16Bytes[0];
    res.padTo16Bytes[1] = val.padTo16Bytes[1];
    res.padTo16Bytes[2] = val.padTo16Bytes[2];
    return res;
};
#endif
#ifndef PxRaycastHit_OUT
__forceinline PxRaycastHit_Managed PxRaycastHit_OUT(const PxRaycastHit& val) {
    PxRaycastHit_Managed res;
    res.actor = val.actor;
    res.shape = val.shape;
    res.faceIndex = val.faceIndex;
    res.flags = (PxHitFlag::Enum) (PxU32) val.flags;
    res.position.x = val.position.x;
    res.position.y = val.position.y;
    res.position.z = val.position.z;
    res.normal.x = val.normal.x;
    res.normal.y = val.normal.y;
    res.normal.z = val.normal.z;
    res.distance = val.distance;
    res.u = val.u;
    res.v = val.v;
    res.padTo16Bytes[0] = val.padTo16Bytes[0];
    res.padTo16Bytes[1] = val.padTo16Bytes[1];
    res.padTo16Bytes[2] = val.padTo16Bytes[2];
    return res;
};
#endif
struct PxSweepHit_Managed {
    PxRigidActor* actor;
    PxShape* shape;
    PxU32 faceIndex;
    PxHitFlag::Enum flags;
    PxVec3_Managed position;
    PxVec3_Managed normal;
    PxF32 distance;
    PxU32 padTo16Bytes;
};
#ifndef PxSweepHit_IN
__forceinline PxSweepHit PxSweepHit_IN(const PxSweepHit_Managed& val) {
    PxSweepHit res;
    res.actor = val.actor;
    res.shape = val.shape;
    res.faceIndex = val.faceIndex;
    res.flags = (PxHitFlags) (PxU32) val.flags;
    res.position.x = val.position.x;
    res.position.y = val.position.y;
    res.position.z = val.position.z;
    res.normal.x = val.normal.x;
    res.normal.y = val.normal.y;
    res.normal.z = val.normal.z;
    res.distance = val.distance;
    res.padTo16Bytes = val.padTo16Bytes;
    return res;
};
#endif
#ifndef PxSweepHit_OUT
__forceinline PxSweepHit_Managed PxSweepHit_OUT(const PxSweepHit& val) {
    PxSweepHit_Managed res;
    res.actor = val.actor;
    res.shape = val.shape;
    res.faceIndex = val.faceIndex;
    res.flags = (PxHitFlag::Enum) (PxU32) val.flags;
    res.position.x = val.position.x;
    res.position.y = val.position.y;
    res.position.z = val.position.z;
    res.normal.x = val.normal.x;
    res.normal.y = val.normal.y;
    res.normal.z = val.normal.z;
    res.distance = val.distance;
    res.padTo16Bytes = val.padTo16Bytes;
    return res;
};
#endif
struct PxActiveTransform_Managed {
    PxActor* actor;
    void* userData;
    PxTransform_Managed actor2World;
    PxConcreteType::Enum actorType;
};
#ifndef PxActiveTransform_IN
__forceinline PxActiveTransform PxActiveTransform_IN(const PxActiveTransform_Managed& val) {
    PxActiveTransform res;
    res.actor = val.actor;
    res.userData = val.userData;
    res.actor2World.q.x = val.actor2World.q.x;
    res.actor2World.q.y = val.actor2World.q.y;
    res.actor2World.q.z = val.actor2World.q.z;
    res.actor2World.q.w = val.actor2World.q.w;
    res.actor2World.p.x = val.actor2World.p.x;
    res.actor2World.p.y = val.actor2World.p.y;
    res.actor2World.p.z = val.actor2World.p.z;
    return res;
};
#endif
#ifndef PxActiveTransform_OUT
__forceinline PxActiveTransform_Managed PxActiveTransform_OUT(const PxActiveTransform& val) {
    PxActiveTransform_Managed res;
    res.actor = val.actor;
    res.userData = val.userData;
    res.actor2World.q.x = val.actor2World.q.x;
    res.actor2World.q.y = val.actor2World.q.y;
    res.actor2World.q.z = val.actor2World.q.z;
    res.actor2World.q.w = val.actor2World.q.w;
    res.actor2World.p.x = val.actor2World.p.x;
    res.actor2World.p.y = val.actor2World.p.y;
    res.actor2World.p.z = val.actor2World.p.z;
    return res;
};
#endif
struct PxDominanceGroupPair_Managed {
    PxReal dominance0;
    PxReal dominance1;
};
#ifndef PxDominanceGroupPair_IN
__forceinline PxDominanceGroupPair PxDominanceGroupPair_IN(const PxDominanceGroupPair_Managed& val) {
    PxDominanceGroupPair res = PxDominanceGroupPair(0, 0);
    res.dominance0 = val.dominance0;
    res.dominance1 = val.dominance1;
    return res;
};
#endif
#ifndef PxDominanceGroupPair_OUT
__forceinline PxDominanceGroupPair_Managed PxDominanceGroupPair_OUT(const PxDominanceGroupPair& val) {
    PxDominanceGroupPair_Managed res;
    res.dominance0 = val.dominance0;
    res.dominance1 = val.dominance1;
    return res;
};
#endif
struct PxSceneLimits_Managed {
    PxU32 maxNbActors;
    PxU32 maxNbBodies;
    PxU32 maxNbStaticShapes;
    PxU32 maxNbDynamicShapes;
    PxU32 maxNbConstraints;
    PxU32 maxNbRegions;
    PxU32 maxNbObjectsPerRegion;
};
#ifndef PxSceneLimits_IN
__forceinline PxSceneLimits PxSceneLimits_IN(const PxSceneLimits_Managed& val) {
    PxSceneLimits res;
    res.maxNbActors = val.maxNbActors;
    res.maxNbBodies = val.maxNbBodies;
    res.maxNbStaticShapes = val.maxNbStaticShapes;
    res.maxNbDynamicShapes = val.maxNbDynamicShapes;
    res.maxNbConstraints = val.maxNbConstraints;
    res.maxNbRegions = val.maxNbRegions;
    res.maxNbObjectsPerRegion = val.maxNbObjectsPerRegion;
    return res;
};
#endif
#ifndef PxSceneLimits_OUT
__forceinline PxSceneLimits_Managed PxSceneLimits_OUT(const PxSceneLimits& val) {
    PxSceneLimits_Managed res;
    res.maxNbActors = val.maxNbActors;
    res.maxNbBodies = val.maxNbBodies;
    res.maxNbStaticShapes = val.maxNbStaticShapes;
    res.maxNbDynamicShapes = val.maxNbDynamicShapes;
    res.maxNbConstraints = val.maxNbConstraints;
    res.maxNbRegions = val.maxNbRegions;
    res.maxNbObjectsPerRegion = val.maxNbObjectsPerRegion;
    return res;
};
#endif
struct PxContactPairHeader_Managed {
    PxRigidActor* actors[2];
    PxContactPairHeaderFlag::Enum flags;
};
#ifndef PxContactPairHeader_IN
__forceinline PxContactPairHeader PxContactPairHeader_IN(const PxContactPairHeader_Managed& val) {
    PxContactPairHeader res;
    res.actors[0] = val.actors[0];
    res.actors[1] = val.actors[1];
    res.flags = (PxContactPairHeaderFlags) (PxU32) val.flags;
    return res;
};
#endif
#ifndef PxContactPairHeader_OUT
__forceinline PxContactPairHeader_Managed PxContactPairHeader_OUT(const PxContactPairHeader& val) {
    PxContactPairHeader_Managed res;
    res.actors[0] = val.actors[0];
    res.actors[1] = val.actors[1];
    res.flags = (PxContactPairHeaderFlag::Enum) (PxU32) val.flags;
    return res;
};
#endif
struct PxContactPairPoint_Managed {
    PxVec3_Managed position;
    PxReal separation;
    PxVec3_Managed normal;
    PxU32 internalFaceIndex0;
    PxVec3_Managed impulse;
    PxU32 internalFaceIndex1;
};
#ifndef PxContactPairPoint_IN
__forceinline PxContactPairPoint PxContactPairPoint_IN(const PxContactPairPoint_Managed& val) {
    PxContactPairPoint res;
    res.position.x = val.position.x;
    res.position.y = val.position.y;
    res.position.z = val.position.z;
    res.separation = val.separation;
    res.normal.x = val.normal.x;
    res.normal.y = val.normal.y;
    res.normal.z = val.normal.z;
    res.internalFaceIndex0 = val.internalFaceIndex0;
    res.impulse.x = val.impulse.x;
    res.impulse.y = val.impulse.y;
    res.impulse.z = val.impulse.z;
    res.internalFaceIndex1 = val.internalFaceIndex1;
    return res;
};
#endif
#ifndef PxContactPairPoint_OUT
__forceinline PxContactPairPoint_Managed PxContactPairPoint_OUT(const PxContactPairPoint& val) {
    PxContactPairPoint_Managed res;
    res.position.x = val.position.x;
    res.position.y = val.position.y;
    res.position.z = val.position.z;
    res.separation = val.separation;
    res.normal.x = val.normal.x;
    res.normal.y = val.normal.y;
    res.normal.z = val.normal.z;
    res.internalFaceIndex0 = val.internalFaceIndex0;
    res.impulse.x = val.impulse.x;
    res.impulse.y = val.impulse.y;
    res.impulse.z = val.impulse.z;
    res.internalFaceIndex1 = val.internalFaceIndex1;
    return res;
};
#endif
struct PxContactPair_Managed {
    PxShape* shapes[2];
    const PxU8* contactStream;
    PxU32 requiredBufferSize;
    PxU16 contactCount;
    PxU16 contactStreamSize;
    PxContactPairFlag::Enum flags;
    PxPairFlag::Enum events;
    PxU32 internalData[2];
};
#ifndef PxContactPair_IN
__forceinline PxContactPair PxContactPair_IN(const PxContactPair_Managed& val) {
    PxContactPair res;
    res.shapes[0] = val.shapes[0];
    res.shapes[1] = val.shapes[1];
    res.contactStream = val.contactStream;
    res.requiredBufferSize = val.requiredBufferSize;
    res.contactCount = val.contactCount;
    res.contactStreamSize = val.contactStreamSize;
    res.flags = (PxContactPairFlags) (PxU32) val.flags;
    res.events = (PxPairFlags) (PxU32) val.events;
    res.internalData[0] = val.internalData[0];
    res.internalData[1] = val.internalData[1];
    return res;
};
#endif
#ifndef PxContactPair_OUT
__forceinline PxContactPair_Managed PxContactPair_OUT(const PxContactPair& val) {
    PxContactPair_Managed res;
    res.shapes[0] = val.shapes[0];
    res.shapes[1] = val.shapes[1];
    res.contactStream = val.contactStream;
    res.requiredBufferSize = val.requiredBufferSize;
    res.contactCount = val.contactCount;
    res.contactStreamSize = val.contactStreamSize;
    res.flags = (PxContactPairFlag::Enum) (PxU32) val.flags;
    res.events = (PxPairFlag::Enum) (PxU32) val.events;
    res.internalData[0] = val.internalData[0];
    res.internalData[1] = val.internalData[1];
    return res;
};
#endif
struct PxTriggerPair_Managed {
    PxShape* triggerShape;
    PxRigidActor* triggerActor;
    PxShape* otherShape;
    PxRigidActor* otherActor;
    PxPairFlag::Enum status;
    PxTriggerPairFlag::Enum flags;
};
#ifndef PxTriggerPair_IN
__forceinline PxTriggerPair PxTriggerPair_IN(const PxTriggerPair_Managed& val) {
    PxTriggerPair res;
    res.triggerShape = val.triggerShape;
    res.triggerActor = val.triggerActor;
    res.otherShape = val.otherShape;
    res.otherActor = val.otherActor;
    res.status = val.status;
    res.flags = (PxTriggerPairFlags) (PxU32) val.flags;
    return res;
};
#endif
#ifndef PxTriggerPair_OUT
__forceinline PxTriggerPair_Managed PxTriggerPair_OUT(const PxTriggerPair& val) {
    PxTriggerPair_Managed res;
    res.triggerShape = val.triggerShape;
    res.triggerActor = val.triggerActor;
    res.otherShape = val.otherShape;
    res.otherActor = val.otherActor;
    res.status = val.status;
    res.flags = (PxTriggerPairFlag::Enum) (PxU32) val.flags;
    return res;
};
#endif
struct PxConstraintInfo_Managed {
    PxConstraint* constraint;
    void* externalReference;
    PxU32 type;
};
#ifndef PxConstraintInfo_IN
__forceinline PxConstraintInfo PxConstraintInfo_IN(const PxConstraintInfo_Managed& val) {
    PxConstraintInfo res;
    res.constraint = val.constraint;
    res.externalReference = val.externalReference;
    res.type = val.type;
    return res;
};
#endif
#ifndef PxConstraintInfo_OUT
__forceinline PxConstraintInfo_Managed PxConstraintInfo_OUT(const PxConstraintInfo& val) {
    PxConstraintInfo_Managed res;
    res.constraint = val.constraint;
    res.externalReference = val.externalReference;
    res.type = val.type;
    return res;
};
#endif
struct PxControllerState_Managed {
    PxVec3_Managed deltaXP;
    PxShape* touchedShape;
    PxRigidActor* touchedActor;
    ObstacleHandle touchedObstacleHandle;
    PxU32 collisionFlags;
    bool standOnAnotherCCT;
    bool standOnObstacle;
    bool isMovingUp;
};
#ifndef PxControllerState_IN
__forceinline PxControllerState PxControllerState_IN(const PxControllerState_Managed& val) {
    PxControllerState res;
    res.deltaXP.x = val.deltaXP.x;
    res.deltaXP.y = val.deltaXP.y;
    res.deltaXP.z = val.deltaXP.z;
    res.touchedShape = val.touchedShape;
    res.touchedActor = val.touchedActor;
    res.touchedObstacleHandle = val.touchedObstacleHandle;
    res.collisionFlags = val.collisionFlags;
    res.standOnAnotherCCT = val.standOnAnotherCCT;
    res.standOnObstacle = val.standOnObstacle;
    res.isMovingUp = val.isMovingUp;
    return res;
};
#endif
#ifndef PxControllerState_OUT
__forceinline PxControllerState_Managed PxControllerState_OUT(const PxControllerState& val) {
    PxControllerState_Managed res;
    res.deltaXP.x = val.deltaXP.x;
    res.deltaXP.y = val.deltaXP.y;
    res.deltaXP.z = val.deltaXP.z;
    res.touchedShape = val.touchedShape;
    res.touchedActor = val.touchedActor;
    res.touchedObstacleHandle = val.touchedObstacleHandle;
    res.collisionFlags = val.collisionFlags;
    res.standOnAnotherCCT = val.standOnAnotherCCT;
    res.standOnObstacle = val.standOnObstacle;
    res.isMovingUp = val.isMovingUp;
    return res;
};
#endif
struct PxExtendedVec3_Managed {
    PxExtended x;
    PxExtended y;
    PxExtended z;
};
#ifndef PxExtendedVec3_IN
__forceinline PxExtendedVec3 PxExtendedVec3_IN(const PxExtendedVec3_Managed& val) {
    PxExtendedVec3 res;
    res.x = val.x;
    res.y = val.y;
    res.z = val.z;
    return res;
};
#endif
#ifndef PxExtendedVec3_OUT
__forceinline PxExtendedVec3_Managed PxExtendedVec3_OUT(const PxExtendedVec3& val) {
    PxExtendedVec3_Managed res;
    res.x = val.x;
    res.y = val.y;
    res.z = val.z;
    return res;
};
#endif
struct PxStridedData_Managed {
    PxU32 stride;
    const void* data;
};
#ifndef PxStridedData_IN
__forceinline PxStridedData PxStridedData_IN(const PxStridedData_Managed& val) {
    PxStridedData res;
    res.stride = val.stride;
    res.data = val.data;
    return res;
};
#endif
#ifndef PxStridedData_OUT
__forceinline PxStridedData_Managed PxStridedData_OUT(const PxStridedData& val) {
    PxStridedData_Managed res;
    res.stride = val.stride;
    res.data = val.data;
    return res;
};
#endif
struct PxTolerancesScale_Managed {
    PxReal length;
    PxReal mass;
    PxReal speed;
};
#ifndef PxTolerancesScale_IN
__forceinline PxTolerancesScale PxTolerancesScale_IN(const PxTolerancesScale_Managed& val) {
    PxTolerancesScale res;
    res.length = val.length;
    res.mass = val.mass;
    res.speed = val.speed;
    return res;
};
#endif
#ifndef PxTolerancesScale_OUT
__forceinline PxTolerancesScale_Managed PxTolerancesScale_OUT(const PxTolerancesScale& val) {
    PxTolerancesScale_Managed res;
    res.length = val.length;
    res.mass = val.mass;
    res.speed = val.speed;
    return res;
};
#endif
struct PxCookingParams_Managed {
    PxPlatform::Enum targetPlatform;
    float skinWidth;
    bool suppressTriangleMeshRemapTable;
    bool buildTriangleAdjacencies;
    PxTolerancesScale_Managed scale;
    PxMeshPreprocessingFlag::Enum meshPreprocessParams;
    PxReal meshWeldTolerance;
};
#ifndef PxCookingParams_IN
__forceinline PxCookingParams PxCookingParams_IN(const PxCookingParams_Managed& val) {
    PxCookingParams res = PxCookingParams(PxTolerancesScale());
    res.targetPlatform = val.targetPlatform;
    res.skinWidth = val.skinWidth;
    res.suppressTriangleMeshRemapTable = val.suppressTriangleMeshRemapTable;
    res.buildTriangleAdjacencies = val.buildTriangleAdjacencies;
    res.scale.length = val.scale.length;
    res.scale.mass = val.scale.mass;
    res.scale.speed = val.scale.speed;
    res.meshPreprocessParams = (PxMeshPreprocessingFlags) (PxU32) val.meshPreprocessParams;
    res.meshWeldTolerance = val.meshWeldTolerance;
    return res;
};
#endif
#ifndef PxCookingParams_OUT
__forceinline PxCookingParams_Managed PxCookingParams_OUT(const PxCookingParams& val) {
    PxCookingParams_Managed res;
    res.targetPlatform = val.targetPlatform;
    res.skinWidth = val.skinWidth;
    res.suppressTriangleMeshRemapTable = val.suppressTriangleMeshRemapTable;
    res.buildTriangleAdjacencies = val.buildTriangleAdjacencies;
    res.scale.length = val.scale.length;
    res.scale.mass = val.scale.mass;
    res.scale.speed = val.scale.speed;
    res.meshPreprocessParams = (PxMeshPreprocessingFlag::Enum) (PxU32) val.meshPreprocessParams;
    res.meshWeldTolerance = val.meshWeldTolerance;
    return res;
};
#endif
struct PxD6JointDrive_Managed {
    PxReal stiffness;
    PxReal damping;
    PxReal forceLimit;
    PxD6JointDriveFlag::Enum flags;
};
#ifndef PxD6JointDrive_IN
__forceinline PxD6JointDrive PxD6JointDrive_IN(const PxD6JointDrive_Managed& val) {
    PxD6JointDrive res;
    res.stiffness = val.stiffness;
    res.damping = val.damping;
    res.forceLimit = val.forceLimit;
    res.flags = (PxD6JointDriveFlags) (PxU32) val.flags;
    return res;
};
#endif
#ifndef PxD6JointDrive_OUT
__forceinline PxD6JointDrive_Managed PxD6JointDrive_OUT(const PxD6JointDrive& val) {
    PxD6JointDrive_Managed res;
    res.stiffness = val.stiffness;
    res.damping = val.damping;
    res.forceLimit = val.forceLimit;
    res.flags = (PxD6JointDriveFlag::Enum) (PxU32) val.flags;
    return res;
};
#endif
struct PxGroupsMask_Managed {
    PxU16 bits0;
    PxU16 bits1;
    PxU16 bits2;
    PxU16 bits3;
};
#ifndef PxGroupsMask_IN
__forceinline PxGroupsMask PxGroupsMask_IN(const PxGroupsMask_Managed& val) {
    PxGroupsMask res;
    res.bits0 = val.bits0;
    res.bits1 = val.bits1;
    res.bits2 = val.bits2;
    res.bits3 = val.bits3;
    return res;
};
#endif
#ifndef PxGroupsMask_OUT
__forceinline PxGroupsMask_Managed PxGroupsMask_OUT(const PxGroupsMask& val) {
    PxGroupsMask_Managed res;
    res.bits0 = val.bits0;
    res.bits1 = val.bits1;
    res.bits2 = val.bits2;
    res.bits3 = val.bits3;
    return res;
};
#endif
struct PxSpring_Managed {
    PxReal stiffness;
    PxReal damping;
};
#ifndef PxSpring_IN
__forceinline PxSpring PxSpring_IN(const PxSpring_Managed& val) {
    PxSpring res = PxSpring(0, 0);
    res.stiffness = val.stiffness;
    res.damping = val.damping;
    return res;
};
#endif
#ifndef PxSpring_OUT
__forceinline PxSpring_Managed PxSpring_OUT(const PxSpring& val) {
    PxSpring_Managed res;
    res.stiffness = val.stiffness;
    res.damping = val.damping;
    return res;
};
#endif
struct PxJointLinearLimit_Managed {
    PxReal restitution;
    PxReal bounceThreshold;
    PxReal stiffness;
    PxReal damping;
    PxReal contactDistance;
    PxReal value;
};
#ifndef PxJointLinearLimit_IN
__forceinline PxJointLinearLimit PxJointLinearLimit_IN(const PxJointLinearLimit_Managed& val) {
    PxJointLinearLimit res = PxJointLinearLimit(0, PxSpring(0, 0));
    res.restitution = val.restitution;
    res.bounceThreshold = val.bounceThreshold;
    res.stiffness = val.stiffness;
    res.damping = val.damping;
    res.contactDistance = val.contactDistance;
    res.value = val.value;
    return res;
};
#endif
#ifndef PxJointLinearLimit_OUT
__forceinline PxJointLinearLimit_Managed PxJointLinearLimit_OUT(const PxJointLinearLimit& val) {
    PxJointLinearLimit_Managed res;
    res.restitution = val.restitution;
    res.bounceThreshold = val.bounceThreshold;
    res.stiffness = val.stiffness;
    res.damping = val.damping;
    res.contactDistance = val.contactDistance;
    res.value = val.value;
    return res;
};
#endif
struct PxJointLinearLimitPair_Managed {
    PxReal restitution;
    PxReal bounceThreshold;
    PxReal stiffness;
    PxReal damping;
    PxReal contactDistance;
    PxReal upper;
    PxReal lower;
};
#ifndef PxJointLinearLimitPair_IN
__forceinline PxJointLinearLimitPair PxJointLinearLimitPair_IN(const PxJointLinearLimitPair_Managed& val) {
    PxJointLinearLimitPair res = PxJointLinearLimitPair(0, 0, PxSpring(0, 0));
    res.restitution = val.restitution;
    res.bounceThreshold = val.bounceThreshold;
    res.stiffness = val.stiffness;
    res.damping = val.damping;
    res.contactDistance = val.contactDistance;
    res.upper = val.upper;
    res.lower = val.lower;
    return res;
};
#endif
#ifndef PxJointLinearLimitPair_OUT
__forceinline PxJointLinearLimitPair_Managed PxJointLinearLimitPair_OUT(const PxJointLinearLimitPair& val) {
    PxJointLinearLimitPair_Managed res;
    res.restitution = val.restitution;
    res.bounceThreshold = val.bounceThreshold;
    res.stiffness = val.stiffness;
    res.damping = val.damping;
    res.contactDistance = val.contactDistance;
    res.upper = val.upper;
    res.lower = val.lower;
    return res;
};
#endif
struct PxJointAngularLimitPair_Managed {
    PxReal restitution;
    PxReal bounceThreshold;
    PxReal stiffness;
    PxReal damping;
    PxReal contactDistance;
    PxReal upper;
    PxReal lower;
};
#ifndef PxJointAngularLimitPair_IN
__forceinline PxJointAngularLimitPair PxJointAngularLimitPair_IN(const PxJointAngularLimitPair_Managed& val) {
    PxJointAngularLimitPair res = PxJointAngularLimitPair(0, 0, PxSpring(0, 0));
    res.restitution = val.restitution;
    res.bounceThreshold = val.bounceThreshold;
    res.stiffness = val.stiffness;
    res.damping = val.damping;
    res.contactDistance = val.contactDistance;
    res.upper = val.upper;
    res.lower = val.lower;
    return res;
};
#endif
#ifndef PxJointAngularLimitPair_OUT
__forceinline PxJointAngularLimitPair_Managed PxJointAngularLimitPair_OUT(const PxJointAngularLimitPair& val) {
    PxJointAngularLimitPair_Managed res;
    res.restitution = val.restitution;
    res.bounceThreshold = val.bounceThreshold;
    res.stiffness = val.stiffness;
    res.damping = val.damping;
    res.contactDistance = val.contactDistance;
    res.upper = val.upper;
    res.lower = val.lower;
    return res;
};
#endif
struct PxJointLimitCone_Managed {
    PxReal restitution;
    PxReal bounceThreshold;
    PxReal stiffness;
    PxReal damping;
    PxReal contactDistance;
    PxReal yAngle;
    PxReal zAngle;
};
#ifndef PxJointLimitCone_IN
__forceinline PxJointLimitCone PxJointLimitCone_IN(const PxJointLimitCone_Managed& val) {
    PxJointLimitCone res = PxJointLimitCone(0, 0, PxSpring(0, 0));
    res.restitution = val.restitution;
    res.bounceThreshold = val.bounceThreshold;
    res.stiffness = val.stiffness;
    res.damping = val.damping;
    res.contactDistance = val.contactDistance;
    res.yAngle = val.yAngle;
    res.zAngle = val.zAngle;
    return res;
};
#endif
#ifndef PxJointLimitCone_OUT
__forceinline PxJointLimitCone_Managed PxJointLimitCone_OUT(const PxJointLimitCone& val) {
    PxJointLimitCone_Managed res;
    res.restitution = val.restitution;
    res.bounceThreshold = val.bounceThreshold;
    res.stiffness = val.stiffness;
    res.damping = val.damping;
    res.contactDistance = val.contactDistance;
    res.yAngle = val.yAngle;
    res.zAngle = val.zAngle;
    return res;
};
#endif
struct PxMat33_Managed {
    PxVec3_Managed column0;
    PxVec3_Managed column1;
    PxVec3_Managed column2;
};
#ifndef PxMat33_IN
__forceinline PxMat33 PxMat33_IN(const PxMat33_Managed& val) {
    PxMat33 res;
    res.column0.x = val.column0.x;
    res.column0.y = val.column0.y;
    res.column0.z = val.column0.z;
    res.column1.x = val.column1.x;
    res.column1.y = val.column1.y;
    res.column1.z = val.column1.z;
    res.column2.x = val.column2.x;
    res.column2.y = val.column2.y;
    res.column2.z = val.column2.z;
    return res;
};
#endif
#ifndef PxMat33_OUT
__forceinline PxMat33_Managed PxMat33_OUT(const PxMat33& val) {
    PxMat33_Managed res;
    res.column0.x = val.column0.x;
    res.column0.y = val.column0.y;
    res.column0.z = val.column0.z;
    res.column1.x = val.column1.x;
    res.column1.y = val.column1.y;
    res.column1.z = val.column1.z;
    res.column2.x = val.column2.x;
    res.column2.y = val.column2.y;
    res.column2.z = val.column2.z;
    return res;
};
#endif
struct PxVec2_Managed {
    PxReal x;
    PxReal y;
};
#ifndef PxVec2_IN
__forceinline PxVec2 PxVec2_IN(const PxVec2_Managed& val) {
    PxVec2 res;
    res.x = val.x;
    res.y = val.y;
    return res;
};
#endif
#ifndef PxVec2_OUT
__forceinline PxVec2_Managed PxVec2_OUT(const PxVec2& val) {
    PxVec2_Managed res;
    res.x = val.x;
    res.y = val.y;
    return res;
};
#endif
struct PxVec4_Managed {
    PxReal x;
    PxReal y;
    PxReal z;
    PxReal w;
};
#ifndef PxVec4_IN
__forceinline PxVec4 PxVec4_IN(const PxVec4_Managed& val) {
    PxVec4 res;
    res.x = val.x;
    res.y = val.y;
    res.z = val.z;
    res.w = val.w;
    return res;
};
#endif
#ifndef PxVec4_OUT
__forceinline PxVec4_Managed PxVec4_OUT(const PxVec4& val) {
    PxVec4_Managed res;
    res.x = val.x;
    res.y = val.y;
    res.z = val.z;
    res.w = val.w;
    return res;
};
#endif
struct PxMeshScale_Managed {
    PxVec3_Managed scale;
    PxQuat_Managed rotation;
};
#ifndef PxMeshScale_IN
__forceinline PxMeshScale PxMeshScale_IN(const PxMeshScale_Managed& val) {
    PxMeshScale res;
    res.scale.x = val.scale.x;
    res.scale.y = val.scale.y;
    res.scale.z = val.scale.z;
    res.rotation.x = val.rotation.x;
    res.rotation.y = val.rotation.y;
    res.rotation.z = val.rotation.z;
    res.rotation.w = val.rotation.w;
    return res;
};
#endif
#ifndef PxMeshScale_OUT
__forceinline PxMeshScale_Managed PxMeshScale_OUT(const PxMeshScale& val) {
    PxMeshScale_Managed res;
    res.scale.x = val.scale.x;
    res.scale.y = val.scale.y;
    res.scale.z = val.scale.z;
    res.rotation.x = val.rotation.x;
    res.rotation.y = val.rotation.y;
    res.rotation.z = val.rotation.z;
    res.rotation.w = val.rotation.w;
    return res;
};
#endif
